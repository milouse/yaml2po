#!/usr/bin/env ruby
#
# yaml2po, for converting RoR translation YAML to the standard gettext for
#          eventual use with a translation site such as Transifex or a CAT tool
#
# Developed from scripts found in http://git.openstreetmap.org/rails.git/tree/HEAD:/script/locale
#
# Usage:
#  - To create a 'master' .pot
#    yaml2po -P en.yml > translations.pot
#
#  - To create a language's .po
#    yaml2po -l de -t en.yml de.yml > de.po
#
#
# Copyright (C) 2012 Leandro Regueiro <leandro.regueiro AT gmail DOT com>
# Copyright (C) 2009 Thomas Wood
# Copyright (C) 2009 Tom Hughes
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

require 'yaml'
require 'optparse'
require 'time'


def process_msgid_msgstr(string)
  # Escape the " characters and correctly output multiline strings both in msgid and msgstr
  if string.is_a? Hash
    new_string = ''
  else
    new_string = string.gsub("\"", "\\\"")
    new_string = new_string.gsub("\n", "\"\n\"")
  end
  return new_string
end


def iterate(hash, outfile = $stdout, fhash = {}, path = '')
  postr = ''
  hash.each {|key, val|
    fhash[key] = {} unless fhash.has_key? key
    if val.is_a? Hash
      fhash[key] = {} unless fhash[key].is_a? Hash
      iterate(val, outfile, fhash[key], "#{path}#{key}:")
    elsif val.nil?
      $stderr.puts("Warning: Empty key #{path}#{key}")
    else
      outfile.puts('')
      outfile.puts("msgctxt \"#{path}#{key}\"")
      new_source = process_msgid_msgstr(val)
      outfile.puts("msgid \"#{new_source}\"")
      new_translation = process_msgid_msgstr(fhash[key])
      outfile.puts("msgstr \"#{new_translation}\"")
    end
  }
end


def print_header(outfile = $stdout, lang = 'LANGUAGE')
  outfile.puts('# SOME DESCRIPTIVE TITLE.')
  outfile.puts('# Copyright (C) YEAR THE PACKAGE\'S COPYRIGHT HOLDER')
  outfile.puts('# This file is distributed under the same license as the PACKAGE package.')
  outfile.puts('# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.')
  outfile.puts('#')
  if lang == 'LANGUAGE'
    outfile.puts('#, fuzzy')
  end
  outfile.puts('msgid ""')
  outfile.puts('msgstr ""')
  outfile.puts('"Project-Id-Version: PACKAGE VERSION\n"')
  outfile.puts('"Report-Msgid-Bugs-To: \n"')
  current_time = Time.now.strftime('%Y-%m-%-d %H:%M%z')
  outfile.puts("\"POT-Creation-Date: #{current_time}\\n\"")
  if lang == 'LANGUAGE'
    outfile.puts('"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"')
  else
    outfile.puts("\"PO-Revision-Date: #{current_time}\\n\"")
  end
  outfile.puts('"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"')
  if lang == 'LANGUAGE'
    outfile.puts("\"Language-Team: #{lang} <LL@li.org>\\n\"")
  else
    outfile.puts("\"Language-Team: #{lang} <#{lang}@li.org>\\n\"")
  end
  outfile.puts('"MIME-Version: 1.0\n"')
  outfile.puts('"Content-Type: text/plain; charset=UTF-8\n"')
  outfile.puts('"Content-Transfer-Encoding: 8bit\n"')
  # TODO if it is no POT file, put the corresponding plural string for the given language code
  outfile.puts('"Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"')
end


def generate_pot(opts = {})
  return false unless opts[:output_file] and opts[:input_file] and opts[:ref_lang]

  unless File.exists? opts[:input_file]
    $stderr.puts("Error: Specified YAML file #{opts[:input_file]} does not exist.")
    return false
  end

  engfile = YAML::load_file(opts[:input_file])
  if opts[:output_file] == :stdout
    print_header
    iterate(engfile[opts[:ref_lang]])
  else
    outfile = File.new(opts[:output_file], 'w')
    print_header(outfile)
    iterate(engfile[opts[:ref_lang]], outfile)
    outfile.close()
  end

  return true
end


def lang2po(opts = {})
  return false unless opts[:output_file] and opts[:input_file] and opts[:ref_file] and opts[:lang] and opts[:ref_lang]

  unless File.exists? opts[:ref_file]
    $stderr.puts("Error: Specified YAML file #{opts[:ref_file]} does not exist.")
    return false
  end

  unless File.exists? opts[:input_file]
    $stderr.puts("Error: Specified YAML file #{opts[:input_file]} does not exist.")
    return false
  end

  # Generate the PO file only once checked that both files exist
  engfile = YAML::load_file(opts[:ref_file])
  langfile = YAML::load_file(opts[:input_file])

  if opts[:output_file] == :stdout
    outfile = $stdout
  else
    outfile = File.new(opts[:output_file], 'w')
  end

  print_header(outfile, opts[:lang])
  iterate(engfile[opts[:ref_lang]], outfile, langfile[opts[:lang]])

  outfile.close() unless opts[:output_file] == :stdout

  return true
end


options = {
  :create_pot => false,
  :input_file => nil,
  :ref_file => nil,
  :output_file => :stdout
}
opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage:\n      yaml2po -h\n      yaml2po -P source.yml [-o output.pot]\n      yaml2po [-l ref_lang] -L dest_lang [-o file.po] ref_file.yml source_file.yml\n\n"

  opts.on('-P', '--create-pot SOURCE_FILE', 'Source yaml file to create a master .pot file') do |o|
    options[:create_pot] = true
    options[:input_file] = o
  end

  opts.on('-l', '--ref_lang [LANG]', 'Source language code') do |l|
    options[:create_pot] = false
    options[:ref_lang] = l || 'en'
  end

  opts.on('-L', '--lang LANG', 'Destination language code') do |l|
    options[:create_pot] = false
    options[:lang] = l
  end

  opts.on('-o', '--output [FILE]', 'Output file') do |o|
    options[:output_file] = o
  end

  # No argument, shows at tail.  This will print an options summary.
  # Try it and see!
  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts
    exit
  end

end

opt_parser.parse!

unless options[:create_pot]
  if ARGV[0] and ARGV[1]
    options[:ref_file] = ARGV[0]
    options[:input_file] = ARGV[1]
  end
end

if options[:create_pot]
  # Goes this way when generating a POT file
  exit if generate_pot(options)

else
  # Goes this way when generating a PO file with the translation for a given language
  exit if lang2po(options)
end

$stderr.puts opt_parser.help
exit 1
